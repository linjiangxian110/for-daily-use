
简介：此次笔记是本人第一次使用 obsidian 记录学习内容，具体方式为观看哔哩哔哩视频，然后使用 obsidian 记录，关键是不想使用平板记录。此外，此次笔记以王道考研为学习基础进行记录。

# 1.计算机系统概述

## 1.1 计算机的发展

### 1.1.1 

- `计算机系统 = 软件 + 硬件`
- 软件的构成如下：
![[../../00 attachment/3a819dfc8d6042ba6c8bbcc553a9a85.png|900]]

### 1.1.2 - 硬件的发展：

![[../../00 attachment/f75963ebb28f5de39c9ea387bc16b3f.png|900]]![[../../00 attachment/b67a88c251a2a3697bf45f94dd4a7a5.png|900]]
![[../../00 attachment/774d3399e57217edee15f25fcbb5687.png|900]]
![[../../00 attachment/7334eb83650208d2c2dcb63b0efd631.png|900]]

- 有趣的历史：（仙童半导体公司）
![[../../00 attachment/192c9b074548861893d40d2aea2a6b2 1.png|900]]

### 1.1.3 软件的发展

![[../../00 attachment/Pasted image 20250219212858.png|900]]

- 软件的发展有 `编程语言的发展` 和 `系统软件` 的发展，所有的软件都是编程语言编写出来的。

### 总结：（感觉不是很重要）

![[../../00 attachment/Pasted image 20250219214052.png|900]]

## 1.2.1+1.2.2： 计算机硬件的基本组成

### 早期冯诺依曼机

`存储程序的概念`：
![[../../00 attachment/Pasted image 20250219214441.png|900]]

![[../../00 attachment/Pasted image 20250219214808.png|900]]

- 这是冯诺依曼计算机的结构。其中控制器通过从存储器中读取指令，然后控制其他设备的工作，比如读取加法运算指令就控制运算器进行相应的操作。
- 这里所说的硬件和软件是等效的，意思是对于相同的一个操作，使用软件和硬件都能实现；
	但是使用软件可能效率低，使用硬件则需要专门设计一块相应的功能；

- `冯诺依曼计算机的几个特点`：

![[../../00 attachment/Pasted image 20250219220453.png|900]]

1. 这里指令和数据都是以二进制的形式存储与存储器中的，他们的地位相同，我们只是在处理的时候将他们看作指令还是看作数据达到不同的效果。
2. 这里说运算器是中心，实际上的意思是所有的数据都要通过运算器作为中转，即使是输入设备和输出设备我们只想要把数据传入到存储器中，不需要经过计算，依旧要通过运算器。这就导致了机器的效率大大降低。`由此我们改进，得到了现在计算机的结构。`

### 现代的计算机结构

![[../../00 attachment/Pasted image 20250219221145.png|900]]

- 运算器和控制器这两个部件一般会被集成在一起，我们称之为 CPU。

![[../../00 attachment/Pasted image 20250219221312.png|900]]

- 这里的存储器分为主存和辅存，主存就是我们的内存；辅存指的是我们的机械硬盘和固态硬盘，辅存我们看作 I/O 设备。我们平时下载的 APP 等都是存储在辅存中的，只有我们想要使用他们时候才回读取辅存中的相应数据。

### 总结：

![[../../00 attachment/Pasted image 20250219221644.png|900]]

## 1.2.2 各个硬件的工作原理

- 了解一些关于寄存器的问题：[[日常学习#寄存器]]

### 主存储器

![[../../00 attachment/Pasted image 20250220161238.png|900]]

- 这里的比喻很恰当：
  1. 在取数据的时候，主存储器中的 MAR 负责提供数据的地址，CPU 通过控制总线告诉主存储器，要进行的是 `读取操作`。根据地址从存储体中找到数据后交给 MDR 负责，然后我们再从 MDR 获取数据。
  2. 在写入数据时候，同样的 CPU 会通过 MAR 指明他要写入的位置，然后通过控制总线说明要进行的是写入操作，把数据放入 MDR 后，就可以写入存储体了。

#### 存储体

![[../../00 attachment/Pasted image 20250220162201.png|900]]

- 存储体就是用于存储数据，我们把存储体分成了一系列的存储单元，存储单元按顺序都有自己的地址。每个存储单元存储一串二进制代码，一般来说存储单元存储的二进制数据是 8bit 的倍数。 

![[../../00 attachment/Pasted image 20250220162639.png|900]]

- 了解了存储体的构成后，我们便明晰了他和 MAR，MDR 的联系：
  1. MAR 反映了存储单元的个数，比如我们的 MAR 一次可以指明 8 位的 bit，那么他能找到的地址也就 $2^8$
  2. MDR 反映了存储字长；
  3. *注意*：这里的 `一个字` 并不是一个字节的意思，`字` 可能指的是存储单元的存储字长，也可能是别的内容，要根据具体语境。

### 运算器的基本组成

#### 基本概念

![[../../00 attachment/Pasted image 20250220164815.png|900]]

![[../../00 attachment/Pasted image 20250220164844.png|900]]

- 这里完成一整条指令需要三个部分，取指令 -》分析指令 -》执行指令

#### 计算机的工作过程

- 解释：
  1. 这里加一个 `（）` 表示里面的内容，比如 `（MAR）` 表示在 MAR 里面的内容；
  2. `M` 表示主存储器；

![[../../00 attachment/Pasted image 20250220202920.png|900]]

PC（程序计数器：用于存放指令的地址，初始时候为 0，每完成一条指令自动加一）

#1 PC 中是第一条指令的地址，把这个指令的地址传输给 MAR（存储地址寄存器），那么（MAR）=0；
#3 取出存储体中 0 位置处的数据，也就是 000001 0000000101；放入 MDR（存储数据寄存器）；
#4 MDR 把数据通过总线传输给 IR （指令寄存器：存放当前要执行的指令）
#5 IR 把指令传输给 CU 控制单元，经过分析 `操作码` 得知 这是一个 `取数` 的指令，那么就进行对应的操作；
#6 7 8 将地址码传输给 MAR，然后取出 MAR 指向的数据放入 MDR 中；
#9 最后 MDR 把取到的数据送给 ACC（累加器，用于存放操作数，或者运算结果）

![[../../00 attachment/Pasted image 20250220204230.png|900]]

![[../../00 attachment/Pasted image 20250220204632.png|900]]

![[../../00 attachment/Pasted image 20250220204602.png|900]]

![[../../00 attachment/Pasted image 20250220204739.png|900]]

#### 总结

![[../../00 attachment/Pasted image 20250220205048.png|900]]

## 1.2.3 计算机软件

![[../../00 attachment/Pasted image 20250220205520.png|900]]

![[../../00 attachment/Pasted image 20250220205901.png|900]]

- 这里明白 C 和 C++ 是编译型语言，他们需要先由编译器进行编译，变成汇编语言，再由汇编器进行汇编操作变成机器语言，由机器运行；
- JAVA，Python 都是解释型语言，他们直接由解释器一句一句地翻译为机器语言； 

![[../../00 attachment/Pasted image 20250220210745.png|900]]

- 经过前面的计算机的工作过程我们再一次认识到了，硬件和软件的功能等价性。因此我们有了一个 `ISA`，也就是指令集体系结构，他明确规定了一台计算机可以支持哪些指令，以及这些指令的作用和用法。

### 总结：

![[../../00 attachment/Pasted image 20250220211053.png|900]]

## 1.2.4-5 计算机系统的层次结构,工作原理

### 层次结构

![[../../00 attachment/Pasted image 20250220213653.png|900]]

![[../../00 attachment/Pasted image 20250220213952.png|900]]

### 工作原理

![[../../00 attachment/Pasted image 20250220214324.png|900]]

## 1.2.3 计算机的性能指标

### 存储器的性能指标

*容量：*
![[../../00 attachment/Pasted image 20250220214804.png|900 ]]

### CPU 的性能指标

 `主频 时钟周期  CPI CPU执行时间`

![[../../00 attachment/Pasted image 20250220215546.png|900]]

- `主频：` 每秒钟有多少个数字脉冲，也就是每秒钟有多少个时钟周期；

![[../../00 attachment/Pasted image 20250220215955.png|900]]

### 系统整体的性能指标

*吞吐量，数据通路带宽，响应时间*

![[../../00 attachment/Pasted image 20250220220742.png|900]]

*思考*：
![[../../00 attachment/Pasted image 20250220221309.png|900]]

### 总结

![[../../00 attachment/Pasted image 20250220221419.png|900]]

# 2. 数据的表示和运算

## 2.1.1 进位计数制

*进制的书写方式：*
*进制的转换：*
![[../../00 attachment/Pasted image 20250221090935.png|900]]

*拼凑法进制转换：*
![[../../00 attachment/Pasted image 20250221091359.png|900]]

![[../../00 attachment/Pasted image 20250221091501.png|900]]

### 总结：

![[../../00 attachment/Pasted image 20250221091518.png|900]]

## 2.1.2-2.1.3 定点数的表示

 ![[../../00 attachment/Pasted image 20250221091937.png|900]]
*无符号数的表示：*
**![[../../00 attachment/Pasted image 20250221092148.png|900]]

*有符号数的定点表示：*

- 这里的数值部分也叫做尾数。
![[../../00 attachment/Pasted image 20250221093359.png|900]]

### 原码（重要）

![[../../00 attachment/Pasted image 20250221093743.png|900]]

- 这里的小数点都是固定，一个在最右边，一个在最左边，由此确定了每一位置的数的权值，小数点向左权值依次是 0,1,2,4..，向右依次是 0.5,0.25,...
- [X]<sub>原</sub> =1，0010011 这里的逗号只是为了看起来方便将符号位和数值分隔开来。下面使用的 `.` 也是一样的作用；

![[../../00 attachment/Pasted image 20250221094902.png|900]]

### 反码（不是很重要）

![[../../00 attachment/Pasted image 20250221131208.png|900]]

### 补码（重要：原码和补码的转换）

![[../../00 attachment/Pasted image 20250221141549.png|900]]

### 移码（补码的符号位取反，只能表示整数）

![[../../00 attachment/Pasted image 20250221141853.png|900]]

*练习：*
![[../../00 attachment/Pasted image 20250221142453.png|900]]

### 总结：

![[../../00 attachment/Pasted image 20250221142629.png|900]]

## 2.1.2+2.1.3 补码的作用

*补码的作用：*
![[../../00 attachment/Pasted image 20250221153719.png|900]]

![[../../00 attachment/Pasted image 20250221154239.png|900]]

![[../../00 attachment/Pasted image 20250221154751.png|900]]

- 这里的 `模 - a的绝对值 = a 的补数` ，这是补码的原始定义；
- 我们这里知道了补码的作用是为了实现将 减法转换为加法 ，就像调节钟表一样，从 7 点钟调节到 5 点可以逆时针转两格，也可以顺时针转 10 格，这就是我们设计的 `减去 a = 加上 a 的补数`。

*例题：*
![[../../00 attachment/Pasted image 20250221155556.png|800]]

## 2.1.4.1 C 语言中的强制类型转换 (重要)

![[../../00 attachment/Pasted image 20250221161202.png|900]]

- 这里的短整数变长整数，如果是负数的话，高位补 1，这样的话实际上真值还是不变的。
- 有符号数变为无符号数的时候，并不改变符号位，只是将符号位也理解成了数值。

## 2.1.4.2 零扩展&符号扩展

*为什么要对数据进行长度扩展？*

![[../../00 attachment/Pasted image 20250221162342.png|900]]

- 总的来说对于硬件中存储的数据，总要送入 ALU 和通用寄存器中进行操作，但是他们之间的数据长度不完全是一致的；此外我们在软件中写出的数据，比如我们需要一个 int 又或是 short,他们的长度也不完全相同，因此我们要对数据进行长度的扩展。下面我们要考虑的问题就是，扩展时候多出来的位数如何填补？

![[../../00 attachment/Pasted image 20250221163337.png|900]]

## 2.2.1_1 加法器 (基础是数电的知识)

![[../../00 attachment/Pasted image 20250225104429.png|800]]

![[../../00 attachment/Pasted image 20250225104812.png|800]]

![[../../00 attachment/Pasted image 20250225104835.png|800]]

![[../../00 attachment/Pasted image 20250225105129.png|800]]

![[../../00 attachment/Pasted image 20250225105439.png|800]]

 上面的内容是数电的基础，介绍加法器的工作原理。那么我们问题就来了，对于加法器来说，如果计算的结果溢出了，或者是我们有时候需要关系计算的结果是否为 0，计算的结果的正负情况，那么怎么体现呢？我们提出了*标志位*。

![[../../00 attachment/Pasted image 20250225105413.png|800]]

*标志位的工作原理：* 这里 CF 和 OF 的工作原理以后会了解到。具体的电路构成了解即可，但是可以掌握每一个标志是如何计算的，计算针对的是哪一类数。

![[../../00 attachment/Pasted image 20250225110115.png|800]]

### 总结：

![[../../00 attachment/Pasted image 20250225110226.png|800]]

## 2.2.1_2 并行加法器

## 2.2.1_3 算术逻辑单元 ALU

运算器的核心是 ALU，ALU 的核心是加法器；
![[../../00 attachment/Pasted image 20250225110745.png|800]]

ALU 右边的 m bit 的输入是控制信号，也就是告诉 ALU 他要执行的运算是什么。m 的位数与 ALU 的功能总数要对应，比如 ALU 如果有 11 中运算功能，那么 m 的位数至少是 4 位。
*直送：* 不对数据进行处理，直接输出。
![[../../00 attachment/Pasted image 20250225110941.png|800]]

ALU 的内部实现（简单了解）：类似于比如说我们有四种功能集成在 ALU 中，那么通过控制信号的 00,01,10,11 就可以选择输出哪一个结果。
![[../../00 attachment/Pasted image 20250225215401.png|800]]

*PSW（程序状态寄存器/标志寄存器）*：用于存储 ALU 输出的标志信息；

![[../../00 attachment/Pasted image 20250225215715.png|800]]

### 总结：

![[../../00 attachment/Pasted image 20250225215939.png|800]]

## 2.2.2 定点数的移位运算

![[../../00 attachment/Pasted image 20250225220046.png|600]]

### 算术移位

#### 原码

![[../../00 attachment/Pasted image 20250225220229.png|800]]
*定点整数：*
重点在于右移不是简单的 */2* ,当舍弃的是 1 时候，会丢失精度。
同样的左移操作，如果高位舍弃的是 0，相当于 *×2* ,如果高位舍弃的是 1，则同样的会丢失精度。
*定点小数：* 也是同理。
![[../../00 attachment/Pasted image 20250225221919.png|800]]

#### 反码

![[../../00 attachment/Pasted image 20250225222511.png|800]]

对于反码的算术移位，如果是整数的话移位操作与原码是相同的；如果是负数的话，注意补位的时候应当*补 1* 。

#### 补码

![[../../00 attachment/Pasted image 20250225222818.png|800]]

这里我们研究发现，补码的从最右侧的 1 开始，包括他后面的所有数字都是和原码相同的；剩余的左边的数字都是和反码相同的；
所以在进行移位操作时候分别与原码和反码的操作一致。其实也就是，*右移时候高位补 1，左移时候低位补 0*。

![[../../00 attachment/Pasted image 20250225223215.png|800]]

#### 应用举例

![[../../00 attachment/Pasted image 20250225223350.png|600]]

由此我们可以看出计算机实现乘法是由算术移位和加法一起实现的。

### 逻辑移位

