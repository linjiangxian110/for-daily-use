# 一、算法设计思想

本实验的主要目的是通过对一个加权无向图的输入与处理，深入理解图的基本概念及其在计算机中的存储方法。实验通过实现图的多个基本算法，帮助掌握连通图、欧拉图、树和最小生成树等常见图的性质，并能够判断图是否具备这些特性。以下为各个功能模块的设计思想总结：

## 1. **图的存储与初始化：**

**设计思想**：使用邻接矩阵表示图，矩阵中的元素存储边的权值，未连接的顶点使用 `INFINITE` 表示。通过字符数组存储顶点信息。图的初始化包括输入顶点数、边数及每条边的权值，更新邻接矩阵。

## 2. **图的输出（邻接矩阵表示）：**

**设计思想**：输出图的邻接矩阵，显示每个顶点与其他顶点的权值。若不存在边，输出 `∞` 以表示无穷大。

## 3. **判断图是否连通：**

**设计思想**：采用深度优先搜索（DFS）算法，从任意顶点出发遍历图的所有顶点。如果所有顶点都能被访问到，则图为连通图；否则，图为非连通图。

## 4. **判断图是否为欧拉图：**

**设计思想**：欧拉图的条件是图必须连通，且每个顶点的度数为偶数。首先检查图是否连通，然后遍历每个顶点，若其度数为偶数，则为欧拉图。

## 5. **判断图是否为树：**

**设计思想**：树是一种无回路的连通图，且边数为 `vexnum - 1`。通过判断图是否连通，并且边数是否为 `顶点数 - 1` 来确认图是否为树。

## 6. **求最小生成树（Prim 算法）：**

**设计思想**：最小生成树通过逐步选择权值最小的边，将一个顶点一个顶点加入最小生成树。使用 Prim 算法，通过 `closedge` 数组记录每个顶点与生成树的最小边，并动态更新权值，最终得到最小生成树。

## 7. **整体流程：**

- **输入**：输入图的顶点和边的信息。
- **输出**：输出邻接矩阵，判断图的连通性、欧拉性、树性，并计算最小生成树。
- **实现**：逐步实现图的存储、输出、性质判断及最小生成树的求解。

# 二、程序输出分析

## 1. **图的矩阵表示**

- **输出格式**：
    
    - 首先，程序会输出一个矩阵，表示图的邻接矩阵。矩阵中的每个元素代表对应顶点之间的边权值，若两个顶点之间没有边连接，则显示为 `∞`（无穷大）。
    - 顶点是通过字符数组存储，矩阵的第一行和第一列显示的是图的顶点。
    - 对于每一条边，矩阵会显示对应的权值，保证用户能够直观地看到图的结构。
- **输出例子**：
    ![[../../00 attachment/Pasted image 20241229122608.png]]

## 2. **判断图的连通性**

- **输出格式**：
    
    - 程序通过深度优先搜索（DFS）算法判断图是否连通。如果从任意一个顶点出发，可以访问所有其他顶点，则输出“连通图”。如果存在无法访问的顶点，则输出“非连通图”。
- **输出例子**：
![[../../00 attachment/Pasted image 20241229122626.png]]

## 3. **判断图是否为欧拉图**

- **输出格式**：
    
    - 程序会根据图的连通性和每个顶点的度数判断图是否为欧拉图。若图是连通的，且每个顶点的度数均为偶数，则输出“欧拉图”，否则输出“非欧拉图”。
- **输出例子**：
    ![[../../00 attachment/Pasted image 20241229122634.png]]

## 4. **判断图是否为树**

- **输出格式**：
    
    - 程序会检查图是否为树。树的条件是：图必须是连通的，且边数应等于顶点数减 1。如果满足条件，输出“树”，否则输出“非树”。
- **输出例子**：
    ![[../../00 attachment/Pasted image 20241229122640.png]]

## 5. **求最小生成树（Prim 算法）**

- **输出格式**：
    
    - 通过输入一个起始顶点，程序使用 Prim 算法求解最小生成树。输出的是每一步选择的边，即生成树中各顶点的连接顺序和对应的边权值。
- **输出例子**：
![[../../00 attachment/Pasted image 20241229122647.png]]

# 三、遇到的困难

## 1. **问题：输入图的邻接矩阵时未能正确处理输入缓冲区问题**

### **问题分析：**

在输入加权无向图的边时，我们采用了 `scanf_s` 来获取顶点的字符输入，并且使用了 `getchar()` 来清除输入缓冲区中的换行符。这个做法虽然能处理大多数情况，但有时由于输入缓冲区未被正确清理，导致读取字符不准确，或者程序崩溃。

### **解决方法：**

通过合理使用 `getchar()` 来清除缓冲区中的换行符，并确保每次输入后清理缓冲区，使得输入操作更加可靠。特别是在输入边的权值时，需要先读取字符，再读取权值，然后通过 `getchar()` 处理换行符。通过这个方法，避免了输入时的缓冲区干扰，确保了每个输入都能被正确读取。

## 2. **问题：判断图是否连通时，深度优先搜索（DFS）未正确处理所有顶点的访问状态**

### **问题分析：**

在进行图的连通性判断时，使用深度优先搜索（DFS）遍历图的所有节点并标记已访问的顶点。如果没有确保遍历所有的顶点，或者每次 DFS 结束后没有清除访问标记，可能会导致判断错误，尤其是在判断图是否为连通图时。

### **解决方法：**

我们在 `DFSTraverse` 函数中，确保了每次遍历前都清空 `visited` 数组，避免上次的访问状态影响本次的判断。而且，函数 `isConnected` 会在遍历所有顶点后，确认所有顶点都被访问，只有全部顶点被访问过，才认为图是连通的。

代码片段：
![[../../00 attachment/Pasted image 20241229122924.png]]

# 四、学习心得

通过这次图论实验，我们深入理解了图的基本概念及其在计算机中的存储方法，特别是加权无向图的邻接矩阵表示法。在实验中，我们学习了如何输入图的各项数据，判断图的连通性、是否为欧拉图、是否为树，并掌握了如何通过 Prim 算法求解最小生成树。这些算法和概念在实际应用中具有广泛的意义，尤其在网络路由、最短路径、数据结构等领域中有着重要作用。

在实验过程中，我们遇到了一些挑战。例如，在判断图的连通性时，深度优先搜索（DFS）的实现过程中遇到了访问标记未清除的问题，导致连通性判断不准确；在输入过程中，由于缓冲区未及时清理，导致输入读取异常。通过合理清理输入缓冲区并修改 DFS 的实现，我们解决了这些问题。

尤其是在实现 Prim 算法时，我们更加理解了贪心算法的思想和应用，掌握了如何从图的各顶点中逐步选择最小边，最终生成最小生成树。这个过程使我们对算法的细节和优化方法有了更深的认识。

总的来说，这次实验不仅加深了我们对图论基础的理解，还提高了我们在编程中的问题分析和解决能力。通过实践，我们不仅掌握了如何在代码中实现和应用图的相关算法，也为今后进一步学习数据结构和算法打下了坚实的基础。

# 五、任务分工

*孙奕欣*：
- 负责图的基础操作实现：
    - 图的邻接矩阵存储结构的构建与初始化。
    - 输入图的顶点、边，并更新邻接矩阵。
    - 主要算法的实现，包括：
        - 判断图的连通性（深度优先搜索 DFS）。
        - 使用 Prim 算法计算图的最小生成树。

<br/>

*李晨康*：
- 负责图的输入相关部分：
    - 输入顶点和边，处理输入数据的格式和读取， 处理输入缓冲区问题，确保用户输入正确解析。
    - 判断图是否为欧拉图。
- 负责图的输出：
    - 输出图的邻接矩阵（包括处理图中的权值与∞表示）。

<br/>

*张哲*：
- 负责部分辅助功能的实现：
	- 实现图的辅助方法，如获取顶点的位置（`LocateVex`）和邻接顶点（`FirstAdjVex`、`NextAdjVex`）。
- 负责部分判断功能：
	- 判断图是否为树。
- 帮助调试和测试代码，确保算法正确性。
