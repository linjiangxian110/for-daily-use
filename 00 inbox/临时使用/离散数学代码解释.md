# 整体思路

- **菜单驱动的选择界面**：在 `main` 函数中，使用 `display_menu` 函数来显示功能菜单，用户可以选择特定的功能并输入表达式，然后根据用户选择调用相应函数。用户可选择生成真值表、生成 DNF 和 CNF、判断是否为永真式/永假式、判断两个表达式的等价性以及判断蕴涵关系。
    
- **变量的提取与管理**：`extract_variables` 函数遍历表达式，找出其中的逻辑变量并存储到 `vars` 数组中。通过 `get_var_index` 函数来获取变量的索引并维护变量的唯一性，确保每个变量只出现一次。`var_count` 记录变量的数量，并动态更新。
    
- **中缀表达式转后缀表达式**：使用 `infix_to_postfix` 函数将输入的逻辑表达式转换成后缀表达式。这是为了方便后续计算表达式的真值，因为后缀表达式易于基于栈的数据结构进行评估。转换过程中，通过运算符的优先级 `precedence` 函数来确保操作顺序正确。
    
- **后缀表达式的真值计算**：`eval_expr` 函数接收后缀表达式和变量的真值表，然后利用栈计算出表达式的最终结果。每当遇到一个逻辑运算符，函数会弹出栈顶的一个或两个元素进行计算，并将结果压回栈顶。通过遍历后缀表达式实现对表达式的真值计算。
    
- **生成真值表**：`print_truth_table` 函数生成并打印指定表达式的真值表。该函数先将表达式转换为后缀表达式，然后遍历所有变量的组合，每一行输出对应的变量真值和计算结果。`row_count` 决定了真值表的行数，即 `2^var_count`，涵盖了所有可能的变量值组合。
    
- **生成主析取范式 (DNF) 和主合取范式 (CNF)**：`generate_dnf_cnf` 函数通过真值表生成表达式的 DNF 和 CNF。对于每一个真值组合，如果表达式为真，则将该组合加入 DNF；如果表达式为假，则加入 CNF。最后的 DNF 和 CNF 结果输出为逻辑运算符组合的表达式。
    
- **永真式与永假式的判断**：
    
    - `is_tautology` 函数遍历所有可能的真值组合。如果所有组合均为真，则该表达式为永真式。
    - `is_contradiction` 函数同理，检查所有组合是否都为假，以判断是否为永假式。
- **判断等价性与蕴涵关系**：
    
    - `is_equivalent` 判断两个表达式在所有真值组合下的结果是否相同。若相同，则表达式等价。
    - `is_entailment` 判断是否第一个表达式为真时，第二个表达式也为真，以此来确认蕴涵关系。

# 子函数解释

## int get_var_index(char var, BOOL add_new);

 - **参数**:
        - `char var`: 表示逻辑表达式中的变量字符（如 `a`、`b`）。
        - `BOOL add_new`: 表示是否在变量未被找到时添加新变量的布尔值（`TRUE` 表示添加，`FALSE` 表示不添加）。
- **作用**: 查找或添加逻辑变量到变量表 `vars` 中。如果变量已存在则返回其索引，否则根据 `add_new` 决定是否添加该变量并返回其索引。主要用于维护变量的唯一性。

![[../../00 attachment/Pasted image 20241025233955.png|600]]

### 这里使用额外的一个布尔值来判断的作用：

- **确保变量表的唯一性和控制性**：
    
    - 在分析逻辑表达式时，有时仅需要查询变量是否已存在，而不希望添加新变量。通过 `add_new` 控制，可以避免在不必要时扩展变量表 `vars`，从而减少不必要的内存占用和计算操作。
    - 例如，当仅需要验证表达式中是否包含某些特定变量时，可以通过设置 `add_new` 为 `FALSE` 来避免在 `vars` 中重复添加相同变量。
- **灵活处理不同功能中的变量需求**：
    
    - 对于生成真值表、判断等价性等功能，可能需要提前解析并固定所有变量，这时可以设置 `add_new` 为 `TRUE` 来将所有变量添加到表中。
    - 另一方面，某些计算中可能只需要读取变量值而不更改表结构，通过将 `add_new` 设置为 `FALSE`，可以确保不会在无意间扩展变量表。
- **提高函数通用性**：
    
    - `get_var_index` 函数作为变量表的管理工具，具有多样性需求。使用 `add_new` 作为参数可以使得此函数适用于多种场景，避免了硬编码来区分读取和添加变量的需求，使代码更加模块化和易于维护。

## int precedence(char op);

- **参数**:
    - `char op`: 表示逻辑运算符，如 `&` (合取)、`|` (析取)、`!` (否定)、`>` (条件)。
- **作用**: 返回逻辑运算符的优先级数值（越高表示优先级越高），用于中缀表达式转换为后缀表达式时的操作顺序。

![[../../00 attachment/Pasted image 20241025234945.png|600]]

## BOOL eval_expr(char* expr, BOOL* truth_values);

 - **参数**:
        - `char* expr`: 存储后缀格式的逻辑表达式字符串。
        - `BOOL* truth_values`: 指向存储逻辑表达式中每个变量的布尔值数组（真值表的一行）。
- **作用**: 计算后缀表达式 `expr` 的布尔值。通过栈的方式逐步计算表达式中每个操作符和变量的值，最终返回整个表达式的真值。

![[../../00 attachment/Pasted image 20241025235042.png|600]]
![[../../00 attachment/Pasted image 20241025235104.png|600]]

## void print_truth_table(char* expr);

- **参数**:
    - `char* expr`: 表示逻辑表达式的字符串（中缀格式）。
- **作用**: 生成并打印指定表达式的真值表。通过生成变量的所有可能组合，计算表达式在每个组合下的真值，并以表格形式输出。

![[../../00 attachment/Pasted image 20241025235143.png|600]]

## void generate_dnf_cnf(char* expr);

- **参数**:
    - `char* expr`: 表示逻辑表达式的字符串（中缀格式）。
- **作用**: 生成并输出表达式的主析取范式 (DNF) 和主合取范式 (CNF)。通过真值表确定满足条件的变量组合，构建出 DNF 和 CNF 的表达式。

![[../../00 attachment/Pasted image 20241025235214.png|600]]
![[../../00 attachment/Pasted image 20241025235235.png|600]]

## BOOL is_tautology(char* expr);

- **参数**:
    - `char* expr`: 表示逻辑表达式的字符串（中缀格式）。
- **作用**: 判断该表达式是否为永真式（即在所有变量组合下均为真）。如果所有可能的组合结果均为真，则返回 `TRUE`，否则返回 `FALSE`。

![[../../00 attachment/Pasted image 20241025235258.png|600]]

## BOOL is_contradiction(char* expr);

- **参数**:
        - `char* expr`: 表示逻辑表达式的字符串（中缀格式）。
    - **作用**: 判断表达式是否为永假式（即在所有变量组合下均为假）。如果所有组合结果均为假，则返回 `TRUE`，否则返回 `FALSE`。

![[../../00 attachment/Pasted image 20241025235322.png|600]]

## BOOL is_equivalent(char* expr1, char* expr2);

- **参数**:
    - `char* expr1`: 第一个逻辑表达式的字符串（中缀格式）。
    - `char* expr2`: 第二个逻辑表达式的字符串（中缀格式）。
- **作用**: 判断两个表达式是否在所有变量组合下结果相同，即表达式等价性。若两表达式的真值表结果相同，返回 `TRUE`，否则返回 `FALSE`。

![[../../00 attachment/Pasted image 20241025235345.png|600]]

## BOOL is_entailment(char* expr1, char* expr2);

 - **参数**:
        - `char* expr1`: 第一个逻辑表达式的字符串（中缀格式），作为前提。
        - `char* expr2`: 第二个逻辑表达式的字符串（中缀格式），作为结论。
    - **作用**: 判断 `expr1` 是否蕴涵 `expr2`，即在 `expr1` 为真时，`expr2` 是否也总为真。若满足蕴涵关系，返回 `TRUE`，否则返回 `FALSE`。

![[../../00 attachment/Pasted image 20241025235405.png|600]]

## void infix_to_postfix(char* infix, char* postfix);

- **参数**:
    - `char* infix`: 中缀格式的逻辑表达式字符串。
    - `char* postfix`: 用于存储后缀格式的逻辑表达式字符串。
- **作用**: 将中缀表达式转换为后缀表达式。便于后续基于栈的真值计算。

![[../../00 attachment/Pasted image 20241025235435.png|600]]

# 运行结果

### 1. 生成真值表（print_truth_table）

#### 简单用例

- **输入**: `a & b`
- 输出：
![[../../00 attachment/Pasted image 20241026001447.png]]

- **输入**: `(a | b) & (!c | d)`
- 输出：
![[../../00 attachment/Pasted image 20241026001616.png]]

### 2. 生成主析取范式 (DNF) 和主合取范式 (CNF)（generate_dnf_cnf）

#### 简单用例

- **输入**: `a | b`
- 输出：![[../../00 attachment/Pasted image 20241026001704.png]]

- **输入**: `(a & b) | (c & d)`
- 输出：
![[../../00 attachment/Pasted image 20241026001802.png]]

### 3. 判断一个表达式是否为永真式或永假式（is_tautology 和 is_contradiction）

#### 简单用例

- **输入**: `a | !a`
- 输出：
![[../../00 attachment/Pasted image 20241026001843.png]]

- **输入**: `(a & b) & (!a | !b)`
- 输出：
![[../../00 attachment/Pasted image 20241026001953.png]]

### 4. 判断两个命题公式是否等价（is_equivalent）

#### 简单用例

- **输入**:
    - 表达式 1：`a & b`
    - 表达式 2：`b & a`
- 输出：
![[../../00 attachment/Pasted image 20241026002047.png]]

- **输入**:
    - 表达式 1：`(a | b) & (!a | b)`
    - 表达式 2：`b`
- 输出：
![[../../00 attachment/Pasted image 20241026002133.png]]

### 5. 判断一个公式是否蕴涵另一个公式（is_entailment）

#### 简单用例

- **输入**:
    - 表达式 1：`a`
    - 表达式 2：`a | b`
- 输出：

![[../../00 attachment/Pasted image 20241026002211.png]]

- **输入**:

	- 表达式 1：`a & (b | c)`
	- 表达式 2：`a & b`

- 输出：
![[../../00 attachment/Pasted image 20241026002316.png]]
